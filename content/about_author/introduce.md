# 作者的介绍


Jamis Buck（jamis@37singnals.com）。 通过其邮件地址猜测，应该是在37singals，也就是现在的BaseCamp公司。


Jamis Buck是著名的迷宫算法专家，他的地下城算法堪称经典，经久不衰广为流传。

这是他在2011Ruby技术大会上的演讲，虽然不算新了，但相当值得一看，附件包含网页版ppt的中英文页面，迷宫算法演示部分需要html5支持。如果不支持，可以直接用浏览器禁用js，当作普通的页面浏览。

[演讲视频](http://v.youku.com/v_show/id_XMzEwMTgzMTQ4.html?firsttim)  |  [PPT](http://www.jamisbuck.org/presentations/rubyconf2011/)

更多迷宫相关内容请参见他的[博客](http://weblog.jamisbuck.org)：


# 以下是网友对其演讲的翻译，忘记出处了，如有知道的请告知

无论你是否想要在跑步、写作、歌唱、绘画、编程、或者是其它什么领域上得到提升，让它变得更好的关键…

…是苦干。没错，世界上没有秘籍。我想大家都同意这一点。


而问题是，我们有时候会忘记“苦干”真的就是苦干。它是不断地锻炼，不断地做你不擅长的事情，并以此提升技艺。


如果只是重复那些我们所擅长的，则只是在“玩乐”而已，弱点还是弱点，因为自己并没有得到提升。


一定要记住，玩乐不是锻炼。


玩乐和锻炼间的另一个关键区别…


…是要坚持到底…


…并且频繁反复地…


…进行练习。


当你没能坚持反复练习，你锻炼的成效也就大减了。这道理对任何方面的锻炼都适用，不过我现在只想聚焦于专业技能——编程技术的锻炼。


按日程表做练习只是时间管理而已，对于它，我没有兴趣说太多。 我最感兴趣的，是计划——为了成为更好的程序员，你将在编程练习期间所使用的系统化安排。


最后，我要开始向你布道算法经了！


算法属于宏观指南，它们记载了为达成某种任务而需要经由的步骤。同时，算法也造就了各种稀奇古怪的程序员习题，因为…


…它们无处不在！你无法逃避它们，如果你是个程序员，那你就必须使用算法。它们涉及各种复杂度的各种运算。无论你感兴趣的是什么运算，也不管你的水平如何，总会有合适的算法供你进行练习。


而我自己，不擅长的是迷宫生成算法。


我们对迷宫都不陌生。迷宫就是那种从起点一直走到终点，然后不能穿墙的解谜游戏，对不？


没错，不过同时它也是图论的具体化。节点，边，连通，最短路径，生成树…这些元素迷宫一应俱全。


我对一种被称为“完备”迷宫的迷宫类型最感兴趣，这种迷宫只有唯一解，并且没有环路。


这些“完备”迷宫其实就是生成树，这是一种非常容易学习与存档的数据结构，世上有着大量与它相关的算法。


“等等！”你会说“我才发现，原来自己是来听学术演讲的！”
对此我会说，“要的就是惊喜！”


但认真地说，如果你只做些毫无难度的练习，那你的锻炼还有什么意义呢？同样的，如果你想要成为一个更棒的程序员，那你就应该理解一些算法背后的理论。为啥？好吧…


…学习理论就是接受新思想。这会帮助你积累新知识，并且为后续深入研究提供基础。如果没有理论给你的梯子，以后你就会失去很多长见识的机会。


所以，在我们聊图论前，让我先给出一点基础的术语吧。对于你们中的部分人来说，这可能只是复习而已，因此我只是快速地过一遍。


这是一个顶点，或者叫做节点。而在这次演讲中，我还会称之为一个单元格。在此，它只是被描绘成了一个点，但它其实可以是任何东西，可能是一个具体的对象，也可能是一个抽象的概念。


这是一条边，它表示两点间的关系。在此，它被描绘成了一条连接两点的线段。


所谓的图就是顶点与连接它们的边的集合。如果你可以通过边，从一个点抵达图上任意的另一点，那这张图就是连通的。这张图还有一个环，或者叫回路。


如果你移除了那个环…


…你就得到了一张无环图。而下面这个连通的的，无环的图…


…就叫做一棵树。


一张图可能会含有多棵树，而每棵树都是由图中点和边的子集所组成的。


当一棵树包含了图上所有的节点时，我们就叫它生成树…


…而生成树正是我所说的“完备迷宫”。


很幸运的是，对世界各地的迷宫爱好者来说，任何一张给出的图都有多种生成树的组合，而潜在生成树的集合就被称为生成森林。所谓的迷宫生成，就是从森林中挑出一棵生成树的行为。理想情况下，我们希望能够从这些树中不带偏见，随机地挑选一棵。当我们以这种方式选出一棵树后，我们就说这棵树是随机生成树。以上就是迷宫生成的词汇复习了。


而接下来的问题就是，我们要如何才能不带偏见地选出生成树，使其足以被称为随机生成树呢？


名为Aldous和Broder的两位研究员提出了这样一种算法。


首先，在图上随机挑选一个节点作为起点。


然后，像酒鬼一样乱走…


…随机从一个点移到另一个点。每当它移入一个还没有被访问的节点时，就把该节点和用于抵达它的边都加入到生成树中。最后，当所有的节点都被访问过，迷宫也就生成出来了。


遗憾的是，虽然它可以确保产生出随机生成树，但它实在是太慢了。虽然可以展示出最终结果，但这却不是随时都可以立即呈现的。


幸运的是，一位名叫Wilson的研究员发现了一种效率更高的算法。


这种算法首先将起点加入图中，然后从另一个点向这个起点散发出“触须”。


像Aldous和Broder的一样，Wilson的算法也使用了酒鬼乱走法以“试探”将采取的路径。


标记路径的结果，是一旦发现从A到B的路径，就会将其添加进生成树中，然后重复这个过程。只不过往后，任何已经在树中的点都将是合法的“B点”，所以后续的迭代会完成的更快一些。


虽然这是一种对Aldous-Broder算法的改良，但它还是挺慢的，尤其是在迷宫的尺寸变得很大的时候。


不过幸运的是，如果你不介意你的迷宫不够随机，那你就可以更快地生成它们了。这些不够随机的迷宫被称为偏倚迷宫，这意味着它们整体上会呈现出一个或更多一成不变的属性。扭曲的路径，大量的死路，廉价的解法，这些都是偏倚迷宫的表现。


“二叉树”算法是最偏倚迷宫算法中的一种，但它同时也是实现起来最为廉价的一种算法。


它的基本方针是：对图中的每个顶点，都在“北”通路和“西”通路之间随机选择一个。


如你所见，这个算法对斜线通路有着明显的偏向性，但对于一些应用而言这倒是可以接受的。而对于那些需要更少偏倚的应用而言…

…你可能会考虑Sidewinder算法。有这样一个酷酷的名字，它一定也是个惊艳的算法，对不？


比起孤立地寻找单个格子，Sidewinder算法则是去寻找一组邻近的格子。 这样的每一组格子都会作为连接集被添加进生成树中，然后在每组中随机挑选一个格子并赋予其北向通路。


显而易见，偏向明显地比二叉树要少了。但如果你跟踪一条从迷宫底部到迷宫顶部的路径，你就会发现解法相当的廉价了：路径倾向于垂直移动，而很少受到阻碍。

在这三种算法中，Eller算法有着最少的偏向，但它也是最为复杂的，这个算法需要技巧才能理解和实现。


它的方法是随机决定是否合并相邻的集合。


一旦你决定了用给定行的哪个集进行合并，接下来就要决定为每个集添加一条或者多条“向下”的连接了。


通过向下连接，节点将被添加进添加它的集合里。然后，在下一行对那些尚未分配到某集合的单元格重复这个过程。


就结果而言，这个算法所产生出的迷宫要比二叉树和Sidewinder产生出的更加随机。但即便如此，Eller算法生成的也依旧是偏倚迷宫。最显著的偏倚表现，是迷宫的最后一行倾向于成为一条孤立的长长走廊。

现在，来看看是什么让Aldous-Broder算法和Wilson算法如此的成功吧，我们可能会认为是酒鬼乱走的缘故。而幸运的是，世上有一类算法比Aldous-Broder算法和Wilson算法更有效率地使用了酒鬼乱走法，Hunt and Kill就是它们中的第一个。


这个算法分为两个阶段，而“追杀”是第一个。


这个阶段进行了酒鬼乱走，不过还附带一个约束条件：不能踏入之前访问过的节点。这就意味着，该算法最终将会走入一条死路，而到了这个时候…


…它就进入了“狩猎”模式。


在狩猎模式下，这个算法会逐行搜索与已访问节点相邻的未访问节点。当它找到这样的一个节点时，就会连接起这两个节点，然后…


…以这个刚找到的未访问节点为起点，再度进入“追杀”模式。如果在“狩猎”阶段没有发现这样的节点，那这个算法就完成了迷宫的生成。


“Hunt-and-Kill”算法倾向于创造一个有着长长曲折通路的迷宫，而拜其所赐，迷宫的死胡同会很少。

不过它比同类算法要略慢些，因为每当走入死路要寻找下一个起点时，它就必须搜索（潜在的）整个区域。


接着是递归回溯法。虽然它还是个迷宫求解的技术，但是反过来也能够很好的生成它们.


和Hunt-and-Kill一样，递归回溯法也从某个起点开始进行酒鬼乱走，不过…


…它会把自己访问的每个节点都推入栈中。


当它走到死路时，并不是进行一次复杂度O(n)的搜索，而是从它的栈里弹出节点，直到找出一个可以从那里继续开始行走的节点为止。


回溯法也和Hunt-and-Kill算法一样有着偏倚问题，换句话说，就是比其它算法更倾向于生成长长曲折的通路，而死路则会相对较少些。

递归分割算法是另一种基于递归的算法，但它的操作方式却和任何我所知道的算法都要大不相同。


本质上，它把区域一分为二，然后递归继续将子区域一分为二，直到方案满足要求为止。


虽然这个算法看上去很有趣，但它倾向于创造出“瓶顶”，或是那些任何潜在解都必须通过的格子。这就意味着，它所创造的迷宫会比其它算法的更容易求解。

Kruskal算法其实是一种用于给加权连通图创建最小生成树的算法。但不管怎样，如果我们用随机数代替了权值，那就得到了一个随机生成树的生成器！


它的基本原理是：如果你把每个顶点都当作是一块橡皮泥…


…那这个算法就是通过随机合并相邻的橡皮泥来运作的。但是，它只允许合并那些尚未成为同一块橡皮泥的节点。


此外，请思考一下如果你像这样连接了橡皮泥会怎样吧，这里的两个节点在另一个节点的下面连接上了。

在这样的图上运行Kruskal算法后，你得到的就是一个穿行迷宫了，这类迷宫的通路会与其它的通路发生跨越或是被跨越。


就像Kruskal算法一样，Prim算法是另一种为了将加权连通图转变成最小生成树而发明的算法。但如果我们像对Kruskal算法所做的那样，对它也使用随机权重，那我们就可以用它来生成迷宫了。

它的基本思路是随机选择一个起点，将其添加进树，然后将它所有的邻居都标记为“边界”节点。


在后续步骤中，你随机挑选一个边界节点，将其与一个已访问的邻居相连接，然后标记它所有未访问的邻居为“边界”节点。反复重复，直到再没有边界节点为止。


最后一个可能是这些算法中我最喜欢的一个了，因为它明显是可以定制的。

它的基本思路是，从图中随机挑选一个节点，并将其添加进被我称为“激活”的集合里。


然后，在这个算法后续的每一步中，都从这个集合里找出一个节点…


…然后将该节点的一个未访问的邻居添加到集合中。如果这个节点没有未访问的邻居，那就从激活集合中删除它然后再试一次。当激活集合被删空了，这个算法也就完工了。


这个算法最有趣的地方，在于它的行为是根据你从激活集中选择节点的方式而改变的。


比如说，如果你总是选择最后添加的节点…


…那你就会得到和递归回溯法一样的行为。


而如果你是从激活集中随机挑选节点的…


…你得到的行为就会与Prim算法非常的相似了。


好了，这就是我想要介绍的所有算法了，不过为了逗大家一乐…

…我想提一种被我称为“Growing Binary Tree”的算法。它与Growing Tree算法的工作原理很像，不过它不是只添加一个未访问的邻居到激活集，而是添加两个。


这里的关键是，结合两种现有算法的行为，你就会发现新的算法指日可待了，因此这里有着大量练习的机会。

而真正的要点是，如果你想要提升自己，那就需要多做练习！


迷宫算法是帮你做练习很好的工具。如果你正在学习它们，那算法本身可能就是你所需要的练习了。一旦你了解了它们，那就用不熟悉的环境（比如Clojure，Erlang，Prolog，Smalltalk等）来实现它们吧，因为这样可以提供更多的阻力。


最后，你需要寻找的是阻力，不断寻找可以挑战自我的东西吧。为之努力，直到阻力消失为止，然后再去找一些新的挑战。这就是提升技艺的方式，这就是使你不断变强的途径。
